# 主题：Netty-Websocket-Cluster

## 第一部分：项目中使用的技术栈：

- **选用Netty作为核心消息推送服务抗高并发。**
- **分布式服务注册与发现组件采用Alibaba Nacos。**
- **分布式服务配置组件采用Alibaba Nacos。**
- **分布式流量负载均衡采用Spring Cloud Gateway + Spring Cloud LoadBalancer。**
- **分布式消息削峰处理采用中间件Rabbit MQ。**
- **用户与分布式集群连接关系 与 消息暂存 使用中间件Redis 用于高速缓存。**
- **消息持久化存储使用Mysql。**
- **分布式服务通讯组件采用Alibaba Dubbo。**
- **分布式流量控制组件采用Alibaba Sentinel。**
- **采用Nginx作为流量负载均衡器。**
- **采用Apache SkyWalking作为链路追踪器。**

## 第二部分（架构图）：

![image-20250509160139256](C:\Users\21779\AppData\Roaming\Typora\typora-user-images\image-20250509160139256.png)

## 第三部分：项目各部分 分层讲解：

#### 1、客户端与服务器端进行登录授权：

（1）经过Gateway网关后把登录请求转发至身份认证服务，身份认证处理完毕得到授权Token，此步骤中可以添加Redis存储Token并设置过期时间的逻辑，用于服务端对客户端连接的直接管制，还可以在Token失效时自动将用户强制下线。

（2）在授权通过后，Gateway网关服务根据Nacos注册中心的Netty集群注册中心负载均衡选择一台Netty服务器用于客户端的连接。注意：此时并没有真正的建立连接。

（3）同时网关层将路由匹配信息存放到Redis中，由于后续消息发送与接收的路由转发。

（4）将授权的Token返回给客户端保存，用于连接Netty服务器身份授权。

（5）客户端利用Token与Netty服务器建立连接后，Netty服务端需要将channel信息在本机内存中存储。

至此，客户端与服务端顺利的建立了Websocket通讯连接。

#### 2、消息发送：客户端<----->服务器端<----->客户端进行消息通讯：

（1）用户发送单聊消息给另外一位用户，携带Token访问网关层，网关层将消息发送至Rabbit MQ集群中异步削峰处理。

（2）根据在Redis存储的终点用户与Netty服务器集群的映射关系，将消息转发至该服务节点。

（3）服务节点接收到需要推送的消息后 找到对应连接Channel进行消息发送。

（4）离线微服务从MQ中进行消费处理，将消息缓存到Redis中，当用户上线时从Redis中直接拉取离线消息。

（5）存储微服务从MQ中进行消费处理，将消息持久化到Mysql中，状态变为未接受。

至此，客户端与服务端间正确的完成了消息通讯。

#### 3、消息接收：客户端<----->服务端进行消息通讯：

（1）当客户端接收到服务端推送的消息时，需要相应给服务端接收到了消息。

（2）同样将响应结果经过网关层，将消息发送至Rabbit MQ集群中异步削峰处理。

（3）存储微服务接收到MQ消息，将消息状态修改为已接收。

（4）离线微服务接收到MQ消息，将离线消息从Redis集群中移除。

至此，客户端与服务端间正确的进行了消息的接收认证处理。

## 第四部分：在开发过程中遇到的问题：

1、因为Netty消息推送微服务是在Spring Boot的环境中运行，但是Nacos注册中心注册的服务地址是SpringBoot的启动端口，所以在Gateway +
LoadBalancer负载websocket连接请求时，会出现404连接不上的问题，所以在Netty消息推送微服务中，需要额外定义Netty启动端口暴漏给Nacos注册中心作为元数据。同时在Gateway网关微服务中重写LoadBalancer负载，选用自定义元数据netty-port作为负载核心。

2、



